<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='icon1.png') }}">
  <title>Flashcards Master</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary: #4361ee;
      --primary-light: #4895ef;
      --primary-dark: #3a0ca3;
      --success: #4cc9f0;
      --warning: #f72585;
      --danger: #e63946;
      --text: #2b2d42;
      --text-light: #6c757d;
      --bg: #f8f9fa;
      --card-bg: #ffffff;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      --radius: 16px;
      --transition: all 0.3s ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      padding: 16px;
      background-color: var(--bg);
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      color: var(--text);
      line-height: 1.6;
    }

    .container {
      width: 100%;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    .top-bar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: relative;
    }

    .back-button {
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-size: 14px;
      padding: 10px 20px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 8px rgba(67, 97, 238, 0.3);
      transition: var(--transition);
    }

    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(67, 97, 238, 0.4);
    }

    .score {
      font-size: 16px;
      color: var(--primary);
      background: rgba(67, 97, 238, 0.1);
      padding: 8px 16px;
      border-radius: 50px;
      font-weight: 600;
    }

    h1 {
      color: var(--text);
      font-size: 1.8rem;
      font-weight: 800;
      text-align: center;
    }

    .flashcard-wrapper {
      perspective: 1000px;
      width: 100%;
      max-width: 600px;
      height: 380px;
      cursor: pointer;
      position: relative;
    }

    .flashcard {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.6s ease;
    }

    .flashcard.flipped {
      transform: rotateY(180deg);
    }

    .front, .back {
      position: absolute;
      width: 100%;
      height: 100%;
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      backface-visibility: hidden;
      overflow-y: auto;
    }

    .front {
      z-index: 2;
    }

    .back {
      transform: rotateY(180deg);
      background: linear-gradient(135deg, #f5f7ff 0%, #ffffff 100%);
    }

    .card-content {
      font-size: 1.6rem;
      font-weight: 600;
      line-height: 1.5;
      width: 100%;
    }

    .card-label {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 0.9rem;
      color: var(--text-light);
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .hint-text {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
      color: var(--text-light);
      opacity: 0.8;
    }

    .button-container {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }

    button {
      padding: 14px 28px;
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 1rem;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 600;
      min-width: 160px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    button:active {
      transform: scale(0.98);
    }

    .flip-button {
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
      box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
    }

    .response-buttons {
      display: none;
      gap: 16px;
      width: 100%;
      justify-content: center;
      flex-wrap: wrap;
    }

    .response-buttons.show {
      display: flex;
    }

    .response-button {
      min-width: 160px;
    }

    .unknown {
      background: linear-gradient(90deg, var(--danger) 0%, #ff6b6b 100%);
      box-shadow: 0 4px 12px rgba(230, 57, 70, 0.3);
    }

    .somewhat {
      background: linear-gradient(90deg, #ff9e00 0%, #ffaa33 100%);
      box-shadow: 0 4px 12px rgba(255, 158, 0, 0.3);
    }

    .known {
      background: linear-gradient(90deg, var(--success) 0%, #72efdd 100%);
      box-shadow: 0 4px 12px rgba(76, 201, 240, 0.3);
    }

    .progress-container {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      width: 100%;
      font-size: 0.95rem;
      color: var(--text-light);
    }

    .progress-bar-container {
      width: 100%;
      height: 12px;
      background-color: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-light) 0%, var(--primary) 100%);
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 10px;
    }

    /* Position the end screen in the same place as flashcards */
    .end-screen-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .end-screen {
      text-align: center;
      display: none;
      background: var(--card-bg);
      padding: 40px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: 90%;
      max-width: 500px;
    }

    .checkpoint-screen {
      text-align: center;
      display: none;
      background: var(--card-bg);
      padding: 40px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: 90%;
      max-width: 500px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
    }

    .congrats-message {
      font-size: 2rem;
      color: var(--primary);
      margin-bottom: 20px;
      font-weight: 800;
    }

    .stats {
      margin-bottom: 32px;
      font-size: 1.1rem;
      color: var(--text-light);
    }

    .motivational-message {
      font-style: italic;
      margin: 20px 0;
      color: var(--primary-light);
      font-weight: 500;
    }

    .replay-button {
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
      padding: 14px 32px;
      font-size: 1.1rem;
      box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .container {
        gap: 20px;
      }
      
      .top-bar {
        flex-direction: column;
        gap: 16px;
        text-align: center;
      }
      
      h1 {
        font-size: 1.6rem;
        order: -1;
        width: 100%;
      }
      
      .flashcard-wrapper {
        height: 320px;
      }
      
      .front, .back {
        padding: 30px 20px;
      }
      
      .card-content {
        font-size: 1.4rem;
      }
      
      .button-container, .response-buttons {
        flex-direction: column;
        align-items: center;
      }
      
      button {
        width: 100%;
        max-width: 300px;
      }

      .end-screen, .checkpoint-screen {
        padding: 30px 20px;
      }

      .congrats-message {
        font-size: 1.6rem;
      }
    }

    @media (max-width: 480px) {
      .flashcard-wrapper {
        height: 280px;
      }
      
      .card-content {
        font-size: 1.2rem;
      }
      
      .card-label {
        top: 15px;
        left: 15px;
        font-size: 0.8rem;
      }
      
      .hint-text {
        font-size: 0.8rem;
        bottom: 15px;
      }
      
      .congrats-message {
        font-size: 1.5rem;
      }
    }

    /* Animation for card flip */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .container {
      animation: fadeIn 0.5s ease;
    }
    
    /* Remove hover effects on touch devices */
    @media (hover: none) {
      .back-button:hover, button:hover {
        transform: none !important;
      }
      
      .flashcard {
        cursor: default;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="container">
    <div class="top-bar">
      <button class="back-button" onclick="goToMenu()">
        <i class="fas fa-arrow-left"></i>
        Back to Minigames
      </button>
      <h1>Flashcards Master</h1>
      <div class="score" id="scoreDisplay">Score: 0 / 0</div>
    </div>

    <div class="flashcard-wrapper" id="flashcardWrapper">
      <div class="flashcard" id="flashcard">
        <div class="front">
          <div class="card-label">
            <i class="fas fa-question-circle"></i>
            Term
          </div>
          <div class="card-content" id="term">Loading...</div>
        </div>
        <div class="back">
          <div class="card-label">
            <i class="fas fa-lightbulb"></i>
            Definition
          </div>
          <div class="card-content" id="answer">Answer</div>
          <div class="hint-text">How well did you know this?</div>
        </div>
      </div>
      
      <!-- End screen container positioned in the same place as flashcards -->
      <div class="end-screen-container">
        <div class="end-screen" id="endScreen">
          <div class="congrats-message">
            <i class="fas fa-trophy"></i>
            Congratulations!
          </div>
          <div class="stats" id="endStats">You scored 0/0 (0%)</div>
          <button class="replay-button" onclick="resetGame()">
            <i class="fas fa-redo"></i>
            Play Again
          </button>
        </div>
      </div>
      
      <!-- Checkpoint screen for sets of 10 cards -->
      <div class="checkpoint-screen" id="checkpointScreen">
        <div class="congrats-message">
          <i class="fas fa-flag"></i>
          Checkpoint Reached!
        </div>
        <div class="stats" id="checkpointStats">You've completed 10 cards</div>
        <div class="motivational-message" id="motivationalMessage">Keep up the great work!</div>
        <button class="replay-button" onclick="continueFromCheckpoint()">
          <i class="fas fa-forward"></i>
          Continue
        </button>
      </div>
    </div>

    <div class="button-container" id="buttonContainer">
      <button class="flip-button" onclick="flipCard()">
        <i class="fas fa-sync-alt"></i>
        Flip Card
      </button>
    </div>

    <div class="response-buttons" id="responseButtons">
      <button class="response-button unknown" onclick="recordRecall(0)">
        <i class="fas fa-times-circle"></i>
        Didn't know
      </button>
      <button class="response-button somewhat" onclick="recordRecall(1)">
        <i class="fas fa-minus-circle"></i>
        Somewhat
      </button>
      <button class="response-button known" onclick="recordRecall(2)">
        <i class="fas fa-check-circle"></i>
        Knew it!
      </button>
    </div>

    <div class="progress-container">
      <div class="progress-info">
        <span id="progressText">Card 1 of 10</span>
        <span id="masteryText">0% Mastered</span>
      </div>
      <div class="progress-bar-container">
        <div class="progress-bar" id="progressBar"></div>
      </div>
    </div>
  </div>

  <script>
    const originalCards = {
        "title": "Curating Data Readings",
        "creator": "DataCurator",
        "cards": [
            {"term": "Critical Data Studies", "definition": "A field that examines the cultural, ethical, and political dimensions of data. It rejects the view of data as neutral and instead investigates how data is generated, curated, and exerts power within sociotechnical systems."},
            {"term": "Data Assemblage", "definition": "The complex, interconnected sociotechnical system that produces and gives meaning to data. It includes thought, knowledge, finance, politics, materiality, practices, organizations, and laws."},
            {"term": "Raw Data is an Oxymoron", "definition": "The concept that data is never truly raw or untouched. It is always cooked/shaped, framed, and interpreted by human choices, tools, and disciplinary norms before it can function as data."},
            {"term": "Technological Determinism", "definition": "The flawed belief that technology (like Big Data) autonomously drives social change. CDS argues that technology is a product of society that in turn shapes it."},
            {"term": "Apophenia", "definition": "The human tendency to perceive meaningful patterns or connections in random or meaningless data. A significant risk when analyzing large datasets (Check: spurious correlations website)."},
            {"term": "Big Data", "definition": "Datasets that are too large or complex to be processed by traditional software. Characterized by volume, velocity, and variety, and generated continuously."},
            {"term": "Small Data", "definition": "Data that is only generated infrequently (e.g., a national census every 10 years) using inflexible methods."},
            {"term": "Data Holding", "definition": "Informal, often personal storage of data (e.g., backups, personal files). Lacks metadata, standards, and long-term preservation planning."},
            {"term": "Data Archive", "definition": "A formal, curated, and documented collection of data intended for long-term preservation and reuse. Includes data, metadata, and context, and is managed by specialists."},
            {"term": "Trusted Digital Repository (TDR)", "definition": "A certified digital repository that ensures long-term access to data, complying with standards like the Open Archival Information System (OAIS) model."},
            {"term": "Cyber-infrastructure", "definition": "Large-scale, standardized, and interoperable data infrastructures that are cross-institutional (e.g., for genomics or climate data)."},
            {"term": "Data Friction", "definition": "The costs, resistances, and challenges involved in the collection, integration, and sharing of data."},
            {"term": "DIKW Hierarchy", "definition": "A model representing a hierarchy of understanding: Data → Information → Knowledge → Wisdom. Each higher level adds context, meaning, and value."},
            {"term": "Data (in DIKW)", "definition": "Discrete, objective symbols or facts without context or meaning (e.g., the number 72)."},
            {"term": "Information", "definition": "Data that has been processed and organized to be meaningful and relevant for a purpose (e.g., The temperature is 72°F)."},
            {"term": "Knowledge", "definition": "Information that has been understood and internalized through experience and context. It is actionable information that answers how questions."},
            {"term": "Wisdom", "definition": "The evaluated understanding of knowledge. It involves judgment, ethics, values, and understanding long-term consequences. It answers why and cannot be automated."},
            {"term": "Efficiency", "definition": "Doing things right; the use of resources relative to an objective. Can be automated."},
            {"term": "Effectiveness", "definition": "Doing the right things; efficiency multiplied by value. Requires human wisdom and judgment."},
            {"term": "Curating (Data)", "definition": "The practice of selecting, managing, and preserving data. It is not a neutral act but a practice of knowledge creation and power."},
            {"term": "Posthuman Curating", "definition": "A concept where curating is no longer performed solely by humans but is a distributed process involving nonhuman agents like algorithms, software, and platforms."},
            {"term": "Content Curation", "definition": "The mundane, massive-scale practice of selecting and managing online content (e.g., reblogging on Tumblr). Users perform curation while simultaneously becoming data for algorithms."},
            {"term": "The Curatorial", "definition": "A philosophy or distinct field of discourse and thought about the practice and theory of curating."},
            {"term": "Metadata", "definition": "Data about data. It provides crucial context for other data, such as how, when, and by whom it was created. It is not neutral and enacts particular worldviews."},
            {"term": "Quantification", "definition": "The process of turning qualities into quantities. It is not a neutral, descriptive act but a situated, creative, and agential practice deeply entangled with power and world-making."},
            {"term": "Surveillance Capitalism", "definition": "An economic system centered on the commodification of personal data for profit and behavioral prediction and modification."},
            {"term": "Synthetic Data", "definition": "Artificially generated data that mimics the statistical properties of real-world data. Used to address privacy concerns or data scarcity but raises questions about fidelity."},
            {"term": "Data Justice", "definition": "An ethical framework concerned with fairness in the way data is used, highlighting how data-driven systems can reinforce existing inequalities and power structures."},
            {"term": "Metadata Justice", "definition": "The ongoing struggle to resist harmful classifications and update biased metadata standards (e.g., changing illegal aliens to undocumented immigrants in library systems)."},
            {"term": "Digital Divide (in Big Data)", "definition": "The inequality in access to large-scale data resources, creating a divide between Big Data rich institutions (e.g., corporations, well-funded universities) and Big Data poor ones."},
        ]
    };
    
    const allTerms = originalCards.map(c => c.term);
    const allDefs = originalCards.map(c => c.definition);

    let terms = [...allTerms];
    let answers = [...allDefs];
    let masteredCards = new Array(allTerms.length).fill(false);
    let partiallyMasteredCards = new Array(allTerms.length).fill(false);
    let currentCard = 0;
    let knownCount = 0;
    let attemptedCount = 0;
    let checkpointInterval = 10; // Show checkpoint every 10 cards

    // Motivational messages for checkpoints
    const motivationalMessages = [
      "Great progress! You're doing amazing!",
      "Learning is a journey - you're on the right path!",
      "Every card brings you closer to mastery!",
      "Your brain is getting stronger with each card!",
      "Persistence is the key to success!",
      "You're building valuable knowledge!",
      "Keep going - you've got this!",
      "Learning is power, and you're gaining it!",
      "Small steps lead to big achievements!",
      "Your effort is paying off!"
    ];

    const card = document.getElementById('flashcard');
    const termDiv = document.getElementById('term');
    const answerDiv = document.getElementById('answer');
    const progressBar = document.getElementById('progressBar');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const responseButtons = document.getElementById('responseButtons');
    const endScreen = document.getElementById('endScreen');
    const progressText = document.getElementById('progressText');
    const masteryText = document.getElementById('masteryText');
    const endStats = document.getElementById('endStats');
    const flashcardWrapper = document.getElementById('flashcardWrapper');
    const checkpointScreen = document.getElementById('checkpointScreen');
    const checkpointStats = document.getElementById('checkpointStats');
    const motivationalMessage = document.getElementById('motivationalMessage');
    const buttonContainer = document.getElementById('buttonContainer');

    function updateCard() {
      if (terms.length === 0) {
        showEndScreen();
        return;
      }
      
      termDiv.textContent = terms[currentCard];
      answerDiv.textContent = answers[currentCard];
      card.classList.remove('flipped');
      responseButtons.classList.remove('show');
      updateProgress();
    }

    function flipCard() {
      card.classList.toggle('flipped');
      if (card.classList.contains('flipped')) {
        responseButtons.classList.add('show');
      } else {
        responseButtons.classList.remove('show');
      }
    }

    function recordRecall(level) {
      attemptedCount++;
      if (level === 2) {
        knownCount++;
        // Mark the original card as mastered
        const originalIndex = allTerms.indexOf(terms[currentCard]);
        if (originalIndex !== -1) {
          masteredCards[originalIndex] = true;
          partiallyMasteredCards[originalIndex] = false;
        }
      } else if (level === 1) {
        // Mark as partially mastered (will be reviewed again)
        const originalIndex = allTerms.indexOf(terms[currentCard]);
        if (originalIndex !== -1) {
          partiallyMasteredCards[originalIndex] = true;
        }
      } else if (level === 0) {
        // Mark as not mastered (will be reviewed again)
        const originalIndex = allTerms.indexOf(terms[currentCard]);
        if (originalIndex !== -1) {
          partiallyMasteredCards[originalIndex] = true;
        }
      }
      
      scoreDisplay.textContent = `Score: ${knownCount} / ${attemptedCount}`;
      responseButtons.classList.remove('show');
      card.classList.remove('flipped');
      
      // Check if we've reached a checkpoint (every 10 cards)
      if (attemptedCount % checkpointInterval === 0 && terms.length > 0) {
        showCheckpoint();
        return;
      }
      
      // Move to next card or reload unmastered cards
      if (currentCard < terms.length - 1) {
        currentCard++;
        updateCard();
      } else {
        reloadUnmasteredCards();
      }
    }

    function reloadUnmasteredCards() {
      terms = [];
      answers = [];
      
      for (let i = 0; i < allTerms.length; i++) {
        if (!masteredCards[i] || partiallyMasteredCards[i]) {
          terms.push(allTerms[i]);
          answers.push(allDefs[i]);
        }
      }
      
      if (terms.length === 0) {
        showEndScreen();
        return;
      }
      
      currentCard = 0;
      updateCard();
    }

    function showCheckpoint() {
      card.style.display = 'none';
      responseButtons.style.display = 'none';
      buttonContainer.style.display = 'none'; // Hide the flip button
      
      // Get a random motivational message
      const randomMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];
      motivationalMessage.textContent = randomMessage;
      
      checkpointStats.textContent = `You've completed ${attemptedCount} cards`;
      
      checkpointScreen.style.display = 'block';
    }

    function continueFromCheckpoint() {
      checkpointScreen.style.display = 'none';
      card.style.display = '';
      responseButtons.style.display = '';
      buttonContainer.style.display = ''; // Show the flip button again
      
      // Move to next card or reload unmastered cards
      if (currentCard < terms.length - 1) {
        currentCard++;
        updateCard();
      } else {
        reloadUnmasteredCards();
      }
    }

    function showEndScreen() {
      card.style.display = 'none';
      responseButtons.style.display = 'none';
      buttonContainer.style.display = 'none'; // Hide the flip button
      document.querySelector('.progress-container').style.display = 'none';
      
      // Update end screen stats
      const percentage = attemptedCount > 0 ? Math.round((knownCount / attemptedCount) * 100) : 0;
      endStats.textContent = `You scored ${knownCount}/${attemptedCount} (${percentage}%)`;
      
      endScreen.style.display = 'block';
    }

    function resetGame() {
      // Reset all game state
      terms = [...allTerms];
      answers = [...allDefs];
      masteredCards = new Array(allTerms.length).fill(false);
      partiallyMasteredCards = new Array(allTerms.length).fill(false);
      currentCard = 0;
      knownCount = 0;
      attemptedCount = 0;
      
      // Reset UI
      card.style.display = '';
      responseButtons.style.display = '';
      buttonContainer.style.display = ''; // Show the flip button
      document.querySelector('.progress-container').style.display = '';
      endScreen.style.display = 'none';
      checkpointScreen.style.display = 'none';
      
      // Update display
      scoreDisplay.textContent = `Score: 0 / 0`;
      updateCard();
    }

    function updateProgress() {
      const percent = ((currentCard + 1) / terms.length) * 100;
      progressBar.style.width = `${percent}%`;
      
      // Update progress text
      progressText.textContent = `Card ${currentCard + 1} of ${terms.length}`;
      
      // Calculate mastery percentage
      const masteredCount = masteredCards.filter(card => card).length;
      const masteryPercent = Math.round((masteredCount / allTerms.length) * 100);
      masteryText.textContent = `${masteryPercent}% Mastered`;
    }

    function goToMenu() {
      location.href = "{{ url_for('minigames') }}?deck_id={{ deck['id'] if deck else 'test' }}";
    }

    // Touch and click events
    card.addEventListener('click', function(e) {
      // Flip only if user clicks inside the visible card (front or back)
      if (e.target.closest('.front') || e.target.closest('.back')) {
        flipCard();
      }
    });
    
    // Keyboard support
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'Enter') {
        flipCard();
      } else if (e.key === '1') {
        recordRecall(0);
      } else if (e.key === '2') {
        recordRecall(1);
      } else if (e.key === '3') {
        recordRecall(2);
      }
    });

    // Initialize the game
    updateCard();
  </script>

</body>
</html>